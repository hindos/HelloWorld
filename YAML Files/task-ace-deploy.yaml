apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  creationTimestamp: '2021-03-23T11:03:21Z'
  generation: 9
  managedFields:
    - apiVersion: tekton.dev/v1beta1
      fieldsType: FieldsV1
      fieldsV1:
        'f:spec':
          .: {}
          'f:params': {}
          'f:stepTemplate':
            .: {}
            'f:name': {}
            'f:resources': {}
            'f:volumeMounts': {}
          'f:steps': {}
          'f:volumes': {}
      manager: Mozilla
      operation: Update
      time: '2021-04-19T22:05:31Z'
  name: ace-deploy
  namespace: henda
  resourceVersion: '36620128'
  selfLink: /apis/tekton.dev/v1beta1/namespaces/henda/tasks/ace-deploy
  uid: b629b176-c699-415c-b3b7-348e50069e4f
spec:
  params:
    - name: git-url
      type: string
    - name: git-revision
      type: string
    - name: source-dir
      type: string
    - name: image-name
      type: string
    - name: image-tag
      type: string
    - name: registry-location
      type: string
    - name: registry-namespace
      type: string
    - name: app-namespace
      type: string
    - name: app-name
      type: string
    - name: tools-image
      type: string
    - name: api-server
      type: string
    - name: private-lan-id
      type: string
    - name: private-ip
      type: string
    - name: configurations
      type: string
    - name: min-memory
      type: string
    - name: max-memory
      type: string
    - name: min-cpu
      type: string
    - name: max-cpu
      type: string
    - name: worker-node
      type: string
    - name: replicas
      type: string
  stepTemplate:
    name: ''
    resources: {}
    volumeMounts:
      - mountPath: $(params.source-dir)
        name: source
  steps:
    - env:
        - name: GIT_PASSWORD
          valueFrom:
            secretKeyRef:
              key: password
              name: ibm-git-credentials
              optional: true
        - name: GIT_USERNAME
          valueFrom:
            secretKeyRef:
              key: username
              name: ibm-git-credentials
              optional: true
      image: $(params.tools-image)
      name: git-clone
      resources: {}
      script: |
        set +x
        if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
            git clone "$(echo $(params.git-url) | awk -F '://' '{print $1}')://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F '://' '{print $2}')" $(params.source-dir)
        else
            set -x
            git clone $(params.git-url) $(params.source-dir)
        fi
        set -x
        cd $(params.source-dir)
        git checkout master
    - image: $(params.tools-image)
      name: json
      resources: {}
      script: |
        #!/usr/bin/env bash
        cat > $(params.source-dir)/deploy.json <<- EOM
        {
          "apiVersion": "appconnect.ibm.com/v1beta1",
          "kind": "IntegrationServer",
          "metadata": {
            "name": "name",
            "namespace": "namespace"
          },
          "spec": {
            "disableRoutes" : true,
            "adminServerSecure" : false,
            "barURL": "",
            "configurations": [],
            "designerFlowsOperationMode": "disabled",
            "license": {
              "accept": true,
              "license": "L-APEH-BSVCHU",
              "use": "AppConnectEnterpriseProduction"
            },
            "pod": {
              "containers": {
                "runtime": { 
                  "livenessProbe" : { "initialDelaySeconds": 1200 },
                  "image": "image",
                  "imagePullPolicy": "IfNotPresent",
                  "resources": {
                    "limits": { "cpu": "500m", "memory": "512Mi" },
                    "requests": { "cpu": "250m", "memory": "250Mi" }
                  }
                }
              }
            },
            "replicas": 1,
            "router": { "timeout": "120s" },
            "service": 
            { 
              "endpointType": "https",
              "ports": [
                {
                    "name": "debug",
                    "port": 9175,
                    "protocol": "TCP",
                    "targetPort": 9175
                }
              ]
            },
            "tracing": { "enabled": false },
            "useCommonServices": false,
            "version": "11.0.0.11-r1"
          }
        }
        EOM
    - env:
        - name: OPENSHIFT_PASSWORD
          valueFrom:
            secretKeyRef:
              key: OPENSHIFT_PASSWORD
              name: openshift-access
              optional: false
        - name: OPENSHIFT_USER
          valueFrom:
            secretKeyRef:
              key: OPENSHIFT_USER
              name: openshift-access
              optional: false
      image: $(params.tools-image)
      name: deploy
      resources: {}
      script: >
        #!/usr/bin/env bash


        echo "$(date): $0 starting..."


        PIPELINE_IMAGE_URL="$(params.registry-namespace)/$(params.image-name):$(params.image-tag)"

        PROJECT_NAME=$(params.image-name)

        #remove blanks

        NAMESPACE=`echo $(params.app-namespace) | sed 's/ *$//g'`

        REPLICAS=`echo $(params.replicas) | sed 's/ *$//g'`

        API_SERVER=`echo $(params.api-server) | sed 's/ *$//g'`

        PRIVATE_VLAN=`echo $(params.private-lan-id) | sed 's/ *$//g'`

        PRIVATE_IP=`echo $(params.private-ip) | sed 's/ *$//g'`

        CONFIGURATIONS=`echo $(params.configurations) | sed 's/ *$//g'` 

        MIN_CPU=`echo $(params.min-cpu) | sed 's/ *$//g'` 

        MAX_CPU=`echo $(params.max-cpu) | sed 's/ *$//g'` 

        MIN_MEMORY=`echo $(params.min-memory) | sed 's/ *$//g'` 

        MAX_MEMORY=`echo $(params.max-memory) | sed 's/ *$//g'` 

        WORKER_NODE=`echo $(params.worker-node) | sed 's/ *$//g'` 

        APP_NAME=`echo $(params.app-name) | sed 's/ *$//g'` 


        env


        echo "$(date):oc login ${API_SERVER} -u ${OPENSHIFT_USER} -p <redacted>"


        if ! oc login ${API_SERVER} --insecure-skip-tls-verify -u
        ${OPENSHIFT_USER} -p ${OPENSHIFT_PASSWORD};

        then
           exit 1
        fi



        if [[ -n ${CONFIGURATIONS} ]];

        then
          IFS=',' read -r -a configs <<< "$CONFIGURATIONS"
          for config in "${!configs[@]}"
          do
             count=$(($config+1))

             if [[ $config == 0 ]];
             then
                cat $(params.source-dir)/deploy.json | jq '.spec.configurations += ["'${configs[config]}'"]' > deploy${count}.json
             else
                cat deploy${config}.json | jq '.spec.configurations += ["'${configs[config]}'"]' > deploy${count}.json
             fi

             cp deploy${count}.json deploy-with-configs.json
          done

          cp deploy-with-configs.json deploy1.json 
        else
          cp $(params.source-dir)/deploy.json deploy1.json
        fi


        cat deploy1.json | jq
        '.spec.pod.containers.runtime.resources.limits.cpu="'${MAX_CPU}'"' >
        deploy2.json

        cat deploy2.json | jq
        '.spec.pod.containers.runtime.resources.limits.memory="'${MAX_MEMORY}'"'
        > deploy3.json

        cat deploy3.json | jq
        '.spec.pod.containers.runtime.resources.requests.cpu="'${MIN_CPU}'"' >
        deploy4.json

        cat deploy4.json | jq
        '.spec.pod.containers.runtime.resources.requests.memory="'${MIN_MEMORY}'"'
        > deploy5.json


        if [[ -n ${WORKER_NODE} ]];

        then
              cat deploy5.json | jq '.spec.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms[0].matchExpressions += [{"key":"workernode","operator":"In", "values":["'${WORKER_NODE}'"]}]' > deploy6.json
        else
              cp  deploy5.json deploy6.json
        fi


        cat deploy6.json |  jq '.metadata.name = "'${NAMESPACE}'-'${APP_NAME}'"
        | .metadata.namespace = "'${NAMESPACE}'" |
        .spec.pod.containers.runtime.image="'${PIPELINE_IMAGE_URL}'" |
        .spec.replicas='${REPLICAS}'' > deployment.json


        echo "$(date):editted json"

        cat deployment.json  


        echo "$(date): DRY RUN..."

        echo "$(date): oc apply -f deployment.json --dry-run=client -o yaml"

        oc apply -f deployment.json --dry-run=client -o yaml


        echo "$(date): DEPLOYING..."

        echo "$(date): oc apply -f deployment.json"

        oc apply -f deployment.json


        echo "$(date): Waiting for deploy to take"

        sleep 30s

        echo "$(date): Done waiting for deploy to take"


        DEPLOYMENT_NAME=henda-hello-world-is

        set -x

        if oc rollout status deploy/${DEPLOYMENT_NAME} --watch=true
        --request-timeout="1200s" --namespace ${NAMESPACE}; then
          STATUS="pass"
        else
          STATUS="fail"
        fi

        set +x


        if [ "$STATUS" == "fail" ]; then
          echo "$(date): DEPLOYMENT FAILED"
          exit 1
        else
          echo "$(date): Getting deployment"        
          oc -n ${NAMESPACE} get deployment ${DEPLOYMENT_NAME} -o json >deployed.json

          if [[ $(cat deployed.json|grep varlog|wc -l) -eq 0 ]];
          then
             echo "$(date): No varlog mount/claim found in deployment" 
             
             echo "$(date): Enabling metrics and setting log4j volume and claim"
             cat deployed.json | jq '.spec.template.spec.containers[0].volumeMounts += [{"mountPath": "/home/aceuser/ace-server/log4j/logs", "name": "varlog"}]' >deployed-1.json
             cat deployed-1.json | jq '.spec.template.spec.volumes += [{"name": "varlog", "persistentVolumeClaim": { "claimName": "logs-log4j"} }]' >deployed.json
             cat deployed.json | jq '.spec.template.spec.containers[0].env[1].value="true"' >deployed-1.json
             mv deploy-1.json deploy.json
             
             echo "$(date): Re-applying the deployment"

             oc replace --force --wait=true -n ${NAMESPACE} -f deploy.json

             echo "$(date): Deployed json is as follows:"

             oc -n ${NAMESPACE} get deployment ${DEPLOYMENT_NAME} -o json >deployed.json

             cat deployed.json 

             echo "$(date): DEPLOYMENT COMPLETED - Check Pod is running in namespace ${NAMESPACE}"
          else
             echo "$(date): No re-deploy required - volume mount and claim found - Check Pod is running in namespace ${NAMESPACE}"
          fi

          set -x
          if oc rollout status deploy/${DEPLOYMENT_NAME} --watch=true --request-timeout="1200s" --namespace ${NAMESPACE}; 
          then
            STATUS="pass"
          else
            STATUS="fail"
          fi
          set +x
          
          if [ "$STATUS" == "fail" ]; 
          then
            echo "$(date): Replace of deployment failed"
            exit 1
          else
            if [[ -n ${PRIVATE_VLAN} ]]; then
              echo "$(date): Adding private service"
              oc -n ${NAMESPACE} get service ${DEPLOYMENT_NAME} -o json > service.json
              cat service.json | jq 'del(.spec.clusterIP) | del(.metadata.managedFields) | del(.metadata.creationTimestamp) | del(.metadata.ownerReferences) | del(.metadata.resourceVersion) | del(.metadata.selfLink) | del(.metadata.uid) | .spec.type="LoadBalancer" | .spec.externalTrafficPolicy="Local" | .metadata.annotations."service.kubernetes.io/ibm-load-balancer-cloud-provider-enable-features"="ipvs" | .metadata.annotations."service.kubernetes.io/ibm-load-balancer-cloud-provider-ip-type"="private" | .metadata.annotations."service.kubernetes.io/ibm-load-balancer-cloud-provider-vlan"= "'${PRIVATE_VLAN}'" | .metadata.name=(.metadata.name+"-private")' > private-service.json

              if [[ -n ${PRIVATE_IP} ]]; 
              then
                cat private-service.json | jq '.spec.loadBalancerIP="'${PRIVATE_IP}'"' > private-service-2.json
              else
                cp private-service.json private-service-2.json
              fi

              cat private-service-2.json
              oc apply -f private-service-2.json
            fi
          fi
        fi
      workingDir: $(params.source-dir)
  volumes:
    - emptyDir: {}
      name: source
